/*
* cutlery.js 3.5.5 - https://github.com/lennertderyck/cutleryjs
* Licensed under the GNU GPLv3 license - https://choosealicense.com/licenses/gpl-3.0/#
*
* Copyright (c) 2020 Lennert De Ryck
*/

"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AppErr=exports.linkRouting=exports.updateClipboard=exports.Toast=exports.connection=exports.fieldTypes=exports.returnTag=exports.returnNode=exports.LocalDB=exports.Api=exports.fetchAPI=exports.cookies=exports.getFormData=exports.eventCallback=exports.Element=exports.node=void 0;/**
  * return a node by css selector
  * @param {string} selector the selector of the element you want to return
  * @param {boolean} multiple set to true if you want to return multiple nodes as an array
  */const node=function(a,b=!1){const c=document.querySelectorAll(a);return!1==b?c[0]:c};/**
 * create new nodes
 */exports.node=node;class Element{/**
     * 
     * @param {string} tagname give the tagname of the type of element you want to create
     */constructor(a){if("string"!=typeof a)throw new Error("The tagname of this new element is not of the type string");try{this.el=document.createElement(a)}catch(a){console.error("Something went wrong when creating a new element. We logged the error message for you convenience:"),console.log(a)}this.content=""}/**
     * 
     * @param {array} array the classes you want to add to the created element
     */class(a){var b=this;if("object"!=typeof a)throw new Error("You should use an array for adding classes to an element");try{a.map(function(a){return b.el.classList.add(a)})}catch(a){console.error("Something went wrong when adding classes. We logged this element and the error message for you convenience:"),console.log(a),console.log(this.el)}}/**
     * 
     * @param {array} array set attributes for the created element with nested array: 
     * [
     *  ['attribute-name', 'attribute value']
     *  ['attribute-name', 'attribute value']
     * ]
     * 
     */attributes(a){var b=this;if("object"!=typeof a)throw new Error("You should use an array for adding attributes to an element");try{a.map(function(a){return b.el.setAttribute(a[0],a[1])})}catch(a){console.error("Something went wrong when adding attribtues. We logged this element and the error message for you convenience:"),console.log(a),console.log(this.el)}}/**
     * 
     * @param {string} input set the innerHTML of the element
     */inner(a){this.el.innerHTML=a||this.content}log(){console.log(this.el)}/**
     * 
     * @param {(node|string)} node css selector or a node
     */append(a="html body"){"string"==typeof a?a=returnNode(a):"object"==typeof a&&(a=a);try{a.appendChild(this.el)}catch(a){console.error("Something went wrong when adding an element. You've probably entered a wrong selector or node element. We logged this element and the error message for you convenience:"),console.log(a),console.log(this.el)}}/**
     * 
     * @param {(node|string)} node css selector or a node
     */prepend(a="html body"){"string"==typeof a?a=returnNode(a):"object"==typeof a&&(a=a);try{a.prepend(this.el)}catch(a){console.error("Something went wrong when adding an element. You've probably entered a wrong selector or node element. We logged this element and the error message for you convenience:"),console.log(a),console.log(this.el)}}return(a){return!a||"node"?this.el:"html"==a?this.el.outerHTML:void 0}}/**
 * set callback to excecute when the given selector en the selector of the event.target are equal
 * @param {string} selector css selector to match the event.target element of an eventListener
 * @param {callback} callback executed script when selectors match
 * @param {boolean} action set to true if the element that has to match is identified by a `data-action` attribute
 */exports.Element=Element;const eventCallback=function(a,b,c=!0){let d=null;d=!0==c?event.target.closest(`[data-action="${a}"]`):event.target.closest(a),d&&b(d)};/**
 * extract formdata, returns a Map object
 * @param {string} formNode css selector of the form
 */exports.eventCallback=eventCallback;const getFormData=function(a){// https://stackoverflow.com/a/14438954/9357283
const b=new Set,c=new FormData(a),d=new Map,e=a.querySelectorAll("[name]");return e.forEach(function(a){b.add({name:a.getAttribute("name"),type:a.getAttribute("type")||"textarea"})}),b.forEach(function(a){const b=c.get(a.name);"number"==a.type?d.set(a.name,parseFloat(b)):"checkbox"==a.type?d.set(a.name,null!=b&&("on"==b||b)):d.set(a.name,b)}),d};/**
 * set, remove and read cookies
 */exports.getFormData=getFormData;const cookies={set(a,b,c){if(c){const a=new Date;a.setTime(a.getTime()+1e3*(60*(60*(24*c))));var d="expires="+a.toGMTString()}else var d="";document.cookie=`${a}=${b}; ${d}; path=/`},get(a){const b=a+"=",d=document.cookie.split(";");for(var e,f=0;f<d.length;f++){for(e=d[f];" "==e.charAt(0);)e=e.substring(1,e.length);if(0==e.indexOf(b))return e.substring(b.length,e.length)}return null}};/**
 * fetch api data and choose the output format
 */exports.cookies=cookies;const fetchAPI={async json(a,b={method:"GET"}){try{let c=await fetch(a,b),d=await c.json();return d}catch{throw new Error("Something went really wrong fetching this api",a)}},async text(a,b={method:"GET"}){try{let c=await fetch(a,b),d=await c.text();return d}catch{throw new Error("Something went really wrong fetching this api",a)}},async html(){}};/**
 * a more complex api to fetch data, wip
 */exports.fetchAPI=fetchAPI;class Api{constructor(a,b={method:"GET"}){this.url=a,this.options=b}async fetch(a=this.options){try{return this.response=await fetch(this.url,this.options),this.response}catch{throw new Error("Something went really wrong fetching this api",url)}}async status(){const a=await this.fetch();return a}async JSON(){const a=await this.fetch();return a.json()}async TEXT(){const a=await this.fetch();return a.text()}// async NODE() {
//     const text = await this.TEXT();
//     const temp = document.createElement('template');
//     temp.innerHTML = text;
//     // const content = temp.content.cloneNode(true);
//     return temp.outerHTML;
// }
}exports.Api=Api;class LocalDB{constructor(a){this.name=a,this.data=[],!1==this.exist()&&window.localStorage.setItem(a,JSON.stringify({name:this.name,data:this.data}))}getData(){const a=window.localStorage.getItem(this.name);return a?JSON.parse(a).data:"There is no localStorage item with this name"}exist(){const a=window.localStorage.getItem(this.name);return!!a&&a}detatch(){return window.localStorage.removeItem(this.name),console.log(`local database '${this.name}' removed`),this.name}store(a){window.localStorage.setItem(this.name,JSON.stringify({name:this.name,data:a}))}addMeta(a){a.map(function(a){a.__id=new Date().getTime()})}add(a,b){const c=this.getData(),d=!1==Array.isArray(a)?[a]:a;this.addMeta(d),this.data=!1==Array.isArray(a)?[...c,...d]:[...c,...d],this.store(this.data),b&&b()}update(a,b,c){const d=this.getData(),e=this.item({__id:a}),f=Object.keys(b);f.map(function(a){console.log(b[a]),console.log(e[a])}),c&&c();for(const d=0;d<e.length;d++)if(e[d].__id===a)return void(e[d].Username=newValue)}remove(a,b){const c=this.getData(),d=Object.keys(a)[0],e=c.findIndex(function(b){return b[d]==a[d]});c.splice(e,1),this.store(c),b&&b()}item(a){const b=this.getData(),c=Object.keys(a)[0];return b.find(function(b){return b[c]==a[c]})}count(){const a=this.getData();return a.length}empty(){this.store([])}}/**
 * returns a node, even if the paramter is set by a string
 * checks if the given attribute is a node, if not it will select and return the node by its selector
 * @param {(string|node)} el 
 * @param {boolean} multiple set to true if you want to return multiple nodes as an array
 */exports.LocalDB=LocalDB;const returnNode=function(a,b=!1){if("object"==typeof a)return a;if("string"==typeof a){const c=document.querySelectorAll(a);return!1==b?c[0]:c}};/**
 * returns the tagname of an element
 * @param {(string|nodes)} el 
 */exports.returnNode=returnNode;const returnTag=function(a){return returnNode(a).tagName.toLowerCase()};/**
 * return the fieldtype of an input element
 * when the parameter is a form then all input elements are returned with their type as a Map object
 * @param {(string|node)} el css selector or node
 */exports.returnTag=returnTag;const fieldTypes=function(a){const b=new Map,c=returnNode(a),d=returnTag(a);if("form"==d){const a=c.querySelectorAll("input, textarea");return a.forEach(function(a){a.type&&a.name?b.set(a.name,a.type):"textarea"==returnTag(a)?b.set(a.name,"textarea"):b.set("no name",a.type)}),b}return"input"==d&&c.type?c.type:"textarea"==d?"textarea":"no element found or type specified"};exports.fieldTypes=fieldTypes;const connection={state(){const a=window.navigator.onLine,b=a?navigator.connection.effectiveType:a;return console.log(`Connection types:\n0: offline\n1: slow\n2: good\n3: strong`),{false:0,"slow-2g":1,"2g":1,"3g":2,"4g":3}[b]},watch(a=null){navigator.connection.addEventListener("change",function(){const b=connection.state();a(b)})}};/**
 * creates a toast
 * @param {string} title title for the toast
 * @param {string} content bodytext for the toast
 * @param {number} timer the time that a toast will be visible, in milliseconds
 */exports.connection=connection;class Toast{constructor({title:a,content:b,timer:c=6e3,classes:d=[],attributes:e=[]}){var f=this;// hide toast 
// remove toast after being hidden
this.toast=new Element("div"),this.toast.class(["toast","animate__animated","animate__fadeInUp","animate__faster",...d]),this.toast.inner(`
            <div class="toast__wrapper">
                <div class="toast__controls">
                <div data-action="closeToast">
                    <i class='bx bx-x'></i>
                </div>
                </div>
                <div class="toast__content">
                <h5 class="toast__title">${a}</h5>
                <div class="toast__body">
                    <p>${b}</p>
                </div>
                </div>
            </div>
            <div class="toast__timer"></div>
        `),this.toast.attributes([["style",`--timer-duration: ${c}ms`]]),this.toast.append("#toasts .toasts__wrapper"),setTimeout(function(){fadeOutNode(f.toast.return())},c),setTimeout(function(){f.toast.return().remove()},c+2000)}}exports.Toast=Toast;const fadeOutNode=function(a){a.classList.remove("animate__fadeInUp"),a.classList.add("animate__fadeOutDown")},updateClipboard=async function(a){const{state:b}=await navigator.permissions.query({name:"clipboard-write"});if("granted"==b||"prompt"==b)try{await navigator.clipboard.writeText(a),console.log("copied")}catch(a){console.error(a)}};/**
 * add text to cliboard
 * @param {string} text the text that has to be copied
 */exports.updateClipboard=updateClipboard;/**
 * check if an anker element leads to an external url
 * @param {(string|node)} el the anker element that is checked
 * @param {string} slug if the page you want to check has a slug you want to left out
 */const linkRouting=function(a,b=""){const c=returnNode(a),d=a.href,e=window.location.href.replace(window.location.hash,"")+b;d.startsWith(e)?window.open(d,"_self"):window.open(d,"_blank")};/**
 * BETA FUNCTIONS
 */exports.linkRouting=linkRouting,Node.prototype.on=function(a){var b=this;const c=a.startsWith("on"),d=void 0===this[a];if(a=!1==c?`on${a}`:a,!1==d)throw new Error(`This type of event (${a}) doesn\'t exist`);return function(c){return b[a]=c}};// Array.prototype.selectOr = function() {
//     console.log(this)
// };
class AppErr{constructor(a){this.send(a)}async send({title:a=null,message:b=null,url:c=window.location.href,error:d=null}){const e=await fetch(`http://err.lennertderyck.be/api/new?title=${a}&message=${b}&url=${c}&error=${d}`);e.error?console.log("Something went wrong when logging error",await e.json()):console.log("New app-error logged",await e.json())}}exports.AppErr=AppErr;